## 索引类型
索引的优点：
- 减少服务器需要扫描的数据量
- 帮组服务器避免排序和临时表
- 可以将随机I/O变为顺序I/O

索引并不是最好的工具，对于非常小的表，全表扫描才是最高效的；对于特大型的表，建立和使用索引的代价也会随之增长，这时候，将数据进行分区或者分库来存储是比较好的选择，也可以建立一个元数据信息表，将分布在不同分区或者不同数据库中的特性信息存储起来；对于TB级别的数据，定位单条记录的意义不大，可以使用块级别的元数据（数据特征）来代替索引

### B-TREE索引
InnoDB使用的索引结构在B-Tree上进行了优化，每一个叶子结点都包含了指向了下一个叶子结点的指针，从而很好的支持了范围查找
- 如果不是按照索引最左边的列开始查找，就不能使用索引
- 不能跳过索引中间的列，如果跳过了中间的列，就只时用到了索引前边的列
- 针对索引的某个列进行范围查找，则这个列右边的列都无法使用索引优化查询，（这种情况下，如果范围值数量有限，可以使用多个等值查询来代替）
### 哈希索引
- 只存储对应hash值，不存储字段值，所以不能使用索引中的值来避免读取行
- hash索引不是按照索引值进行排序的，所以无法用来排序
- 不支持部分索引查找，比如在AB列上建立hash索引，如果只查询A，就不能使用这个索引
- 只支持等值查询
- hash冲突增多的话，有关维护索引的操作代价会变高

模拟hash索引
如果某个长度较大的列需要准确值匹配，可以模拟hash索引来做，增加一个列来存储目标列的hash值，在这个列上做索引来实现加快查询速度
使用加密函数来模拟hash时，可能会出现hash冲突（相同的hash值），所以查询时需要使用hash列和原始列一起匹配

### 空间类型索引
用作地理数据存储

### 全文索引

### 其他


## 高性能索引策略

### 独立的列
  如果索引中的列不是独立的列，索引不会被使用；独立的列是指列不能是表达式的一部分，也不能是函数的参数

#### 索引合并
**参数optimizer_switch可以关闭/开启索引合并功能，INGORE INDEX可以让优化器忽略掉某些索引**
假设下面查询中条件中的字段是有索引的
`select * from actor_a where id = 1 or code_file = 2;
`
在老的版本中会使用全表扫描，新版本中会改写成为两个单个条件的union all；这样就能使用到两个索引
索引合并是一种优化结果，但实际上说明表上的索引建立的并不好：

- 当出现服务器对多个索引做相交操作的时候（通常有多个AND条件），通常意味着需要做一个多列索引，而不是多个单列索引；
- 对多个索引进行联合操作（通常有多个or），需要小号大量的CPU和内存资源在算法缓存、排序和合并操作上，如果索引选择性不高，合并数据量较大的时候，更加消耗性能；
- 某些情况下这种优化下的执行计划还比不上全表扫描；而且优化器并不会吧这些计算到查询成本中，可能出现隐性的查询成本；
### 前缀索引和索引选择性
  对于很长的列进行索引，会让索引变大变慢，可以考虑模拟哈希索引或者做前缀索引，即：索引列开始的部分字符，可以节省索引空间，提高索引效率；但这样降低了索引的选择性；所以需要选择适合的索引长度

### 多列索引
索引的顺序很重要，通常将选择性最高的列放在前面是比较好的考虑

### 聚簇索引
实际数据存放在叶子结点，InnoDB通过主键来实现；
优点：
- 可以将相关数据存放在一起，减少磁盘I/O；
- 数据访问更快，索引和数据在一个结构中；
- 要查询主键的时候，可以直接获取（索引覆盖）；
缺点：
- 虽然最大限度的提升了I/O密集型应用的性能，但是对内存中的数据，访问顺序没有那么重要；
- 插入速度用来插入顺序，按照顺序进行插入最快，但如果不是的话，就没有那么快了
- 更新聚簇索引列代价比较高，每个更新的行会被移动
- 页分裂：插入新行或者主键更新导致行移动的时候，如果被插入的页已满，存储引擎会将页分裂为两个页来容纳该行；页分裂会导致表占用更多的磁盘空间
- 聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏或者页分裂导致数据不连续的时候；
- 非聚簇索引中叶子节点中包含的是主键，索引二级索引查找的时候需要两次才能获得数据；


### 索引覆盖
非聚簇索引查询数据行需要回表，但如果需要查询的列在索引中全部都有，就不需要回表

#### 延时关联

### 使用索引扫描来做排序
	MYSQL有两种方式生成有序结果，通过排序操作或者使用搜索引顺序扫描（type=index）；
	只有索引的顺序和order by的子句的顺序完全一致，并且排序都是正序或都是倒序才能使用
#### 举例
索引 UNIQUE KEY r_d (rental_date, inventory_id, customer_id)
##### 可以使用的情况
`where rental_date = '2000-01-01' order by inventory_id;`
第一列是常量，所以能够使用索引排序

`where rental_date > '2000-01-01' order by rental-date, inventory_id;`
排序是索引的前两列，也能使用索引排序；
##### 不能使用的情况
`where rental_date = '2000-01-01' order by inventory_id desc, customer_id asc;`
使用了不同的排序方向

`where rental_date = '2000-01-01' order by inventory_id, staff_id;`
使用了索引中不存在的列排序

`where rental_date = '2000-01-01' order by customer_id;`
跳过了索引中的列，无法组成最左前缀

`where rental_date > '2000-01-01' order by inventory_id, customer_id;`
第一列是范围条件，无法使用索引的其余列

`where rental_date = '2000-01-01' and inventory_id IN (1, 2) order by customer_id;`
这个查询在索引第二列上有多个等于条件，也是一种范围查询；**如果在某个索引中进行范围查询，也就无法再使用另一个索引或是该索引的后续字段进行排序了**

### 冗余和重复索引
重复的索引是在相同的列上按照相同的顺序建了相同类型的索引，应该避免
```
create table test(
	ID int primary key,
	a int,
	b int, 
	unique(ID),
	index(ID)
) engine=InnoDB;
```
这里是想创建一个主键，先加上唯一限制，再加上索引供查询使用；
事实上，MYSQL的唯一限制和主键限制都是通过索引实现的，因此上面的写法实际上在相同的列上建立了三个重复的索引

冗余索引是某个列被多个索引中包含，比如 ID和key(ID, a);
大多数情况都不需要冗余索引，应该尽量扩展已有的索引而不是创建新的索引；但也有处于性能考虑而冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他查询的性能

### 未使用的索引
删除

### 索引和锁
索引可以让查询锁定更少的行
Extra 中的Using where表示服务器将存储引擎返回行之后在应用where过滤条件；这会导致，锁住了更多的行，而在服务器层面又被丢弃
```
select actor_id for actor where actor_id < 5 and actor_id <> 1 for update
```
在actor_id列上有索引，但是存储引擎获取了actor_id< 5 的记录，却没有去掉1的那条数据，在服务器中才根据条件去掉了这条数据，所以这会锁住<5 的所有数据

### 




