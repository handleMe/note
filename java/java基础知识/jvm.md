# JVM

## JVM结构：
- **类加载器子系统**
类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识；ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定；加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
加载过程：
	- Loading（加载）环节 ：通过一个类的全限定明获取定义此类的二进制字节流；将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
	- Linking（链接）环节：
		- Verify(验证)：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。
		- Prepare(准备)环节：为类变量分配内存并且设置该类变量的默认初始值，即零值；这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。
		- Resolve(解析)：将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。
	- Initialization（初始化）环节：初始化阶段就是执行类构造器方法clinit（）的过程。 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中的出现的顺序执行。Clinit不同于类的构造器（构造器是虚拟机视角下的init（））。若该类有父类，jvm会保证子类的clinit（）执行前，父类的clinit（）已经执行完毕。虚拟机必须保证一个类的clinit（）在多线程下被同步加载。
- **运行时数据区（内存空间）**
  - **方法区 Method Area** ：各线程共享的区域，方法区存储一杯虚拟机加载的类信息、常量、静态变量、即使编译器遍以后的代码等数据。是堆的一个逻辑部分，别名是Non-Heap（非堆）。
    方法区在以前的虚拟机实现中，被列进了永久代中，由于应用的需求越来越大，方法区也跟着成倍的增加，再加上永久代有内存上限的限制，更容易遇到内存溢出问题，这样将方法区放在永久代就有点不合适，所以在jdk1.7中，其中的常量池从方法区中移除，放在了堆里。
    异常：当方法区占用过大时，当没有内存可分配时，将会抛出**OutOfMemoryError**异常。
    	- 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
    	- **7的实现是永久代、8的实现是元空间**
  - **堆heap**：堆是所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例和数组都要在堆上分配，随着技术成熟，这种说法也不是那么绝对；如果堆中没有内存可以完成实例分配，并且也无法再扩展时，会抛出**OutOfMemoryError**异常。
  - **栈 stack**：描述的是Java内存执行的内存模型：每一个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈种入栈到出栈的过程；异常情况：线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常；如果虚拟机栈可以动态扩展（当前大多虚拟机可动态扩展），如果扩展时无法申请到足够的内存，就会抛出**OutOfMemoryError**异常
  - **程序计数器（PC寄存器）** Program Counter Register；一块较小的内存空间，是当前线程所执行的字节码的行号指示器。程序计数器负责字节码解释器工作时通过它来选取下一条需要执行的字节码指令，如分支、循环、跳转、异常处理、线程恢复等基础功能；**java虚拟机中唯一一个没有规定OutOfMemoryError异常的区域**
  - **本地方法栈 Native Method Stack**：原理基本同虚拟机栈相同，区别在于虚拟机栈是为虚拟机执行java方法服务，而本地方法栈是为虚拟机执行Native方法服务
    **异常也会和虚拟机栈一样，会抛出StackOverflowError和OutOfMemoryError**
- **执行引擎**
- **本地方法接口**
- **直接内存**：这不是严格的虚拟机规范中定义的内存区域。但是也会频繁使用，也可能导致OutOfMemoryError异常出现。
    jdk1.4中新增NIO类（New Input/Output），引入了一种基于通道（Channel）与缓存区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著的提高性能，避免了在Java堆和Native堆中来回复制数据。
    本机直接内存分配不受到Java堆大小的限制，但是，既然是内存，肯定会受到本机总内存大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

### 栈
栈空间


## java代码是怎么运行的？
&emsp;&emsp;Java虚拟机具体怎么运行代码？ 1) 加载Java编辑成的class文件到虚拟机，加载好后放到方法区(Method Area) 2) 执行时需要将字节码翻译成机器码，有【解释执行】和【即时编译】(JIT)两种 线程共享： 方法区、堆； 线程私有： PC寄存器、Java方法栈、本地方法栈
&emsp;&emsp;Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。
&emsp;&emsp;为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。
## java基本类型
&emsp;&emsp;boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。
&emsp;&emsp;除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。
&emsp;&emsp;除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。
## jvm加载java类
jvm加载java类就是将字节流(如.class文件，网络传输的字节流)文件加入到内存中的过程，分为以下三步：加载、链接、初始化
&emsp;&emsp;加载：查找字节流并且据此创建类的过程，每一种类加载器加载一部分类
&emsp;&emsp;加载规则：双亲委派机制
&emsp;&emsp;类的唯一性：类加载器名称+类全限定名称
&emsp;&emsp;类加载器：
&emsp;&emsp;启动类加载器：无对应的java对象，负责加载最基础的类。如jre/lib下的类以及有虚拟机参数-Xbootclasspath指定的类，
&emsp;&emsp;扩展类加载器：有对应的java对象，父类启动类加载器,负责加载jre/ext下类以及系统变量java.ext.dirs指定的类
&emsp;&emsp;该类加载器被启动类加载器加载之后方能加载其他类，
&emsp;&emsp;应用类加载器：有对应的java对象，父类是扩展类加载器，负责加载应用程序路径下的类/classpath、系统变量java.class.path或者环境变量classpath指定的类。
链接：验证、准备、解析
&emsp;&emsp;验证：在于确定被加载类满足jvm的约束条件。
&emsp;&emsp;准备：为被加载类的静态字段分配内存。
&emsp;&emsp;解析：将符号引用解析为实际引用，
&emsp;&emsp;&emsp;&emsp;符号引用是在编译阶段由编译器生成，包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型
&emsp;&emsp;初始化：为标记为常量值的字段(基本类型或字符串且被修饰为final)赋值，以及执行``<clinit>``方法(其他赋值操作和静态代码块)类的初始化过程是线程安全的，并且只能被初始化一次。jvm会通过加锁来保证``<clinit>``方法仅被执行一次;初始化的时机（对一个类的主动引用）;被动引用并不会引发类的初始化，如引用类的静态常量，引用父类的静态字段不会初始化子类，数组定义来引用类不会导致初始化。

## jvm执行方法调用
&emsp;&emsp;在 Java 中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。
&emsp;&emsp;Java 虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。在 Java 虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
&emsp;&emsp;由于 Java 编译器已经区分了重载的方法，因此可以认为 Java 虚拟机中不存在重载。在 class 文件中，Java 编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。
&emsp;&emsp;Java 的重写与 Java 虚拟机中的重写并不一致，但是编译器会通过生成桥接方法来弥补。今天的实践环节，我们来看一下两个生成桥接方法的例子。你可以通过“javap -v”来查看 class 文件所包含的方法。
- 方法重载，方法名相同、方法参数类型不同（其中包括参数的个数、类型、次序，三者之中只要有一个不同就行）。以前的理解方法重载是在一个类内，今天读后感觉类间有继承关系也是存在方法重载的，需要验证一下？
- 方法重写，方法名相同、方法参数类型相同、方法返回值相同，类之间有继承关系，便构成方法重写。这个概念和之前一样，不过老师强调了父类中的方法是飞私有、非静态的，这个有待验证一下？
- JVM定位目标方法的关键是类名+方法名+方法参数类型+方法返回值类型，于是就出现了两种JVM找目标方法的方式，静态绑定、动态绑定
- 静态绑定，在解析时JVM便知道该调用那个目标方法
- 动态绑定，在运行时JVM需要根据对应的类类型来具体定位应该调用那个目标方法。对于方法重写，对应的类会拥有一个方法表（一个二维数组表，给方法标上序号，重写的方法序号一致）
### 虚方法
&emsp;&emsp;虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。否则，Java 虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。Java 虚拟机的动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。在解析虚方法调用时，Java 虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。
## jvm如何处理异常
&emsp;&emsp;Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为 RuntimeException 和其他类型。RuntimeException 和 Error 属于非检查异常。其他的 Exception 皆属于检查异常，在触发时需要显式捕获，或者在方法头用 throws 关键字声明。Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。
&emsp;&emsp;Java 7 引入了 Suppressed 异常、try-with-resources，以及多异常捕获。后两者属于语法糖，能够极大地精简我们的代码。

- 使用异常捕获的代码为什么比较耗费性能？
&emsp;&emsp;因为构造异常的实例比较耗性能。这从代码层面很难理解，不过站在JVM的角度来看就简单了，因为JVM在构造异常实例时需要生成该异常的栈轨迹。这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。
&emsp;&emsp;虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。
- finally是怎么实现无论异常与否都能被执行的？
&emsp;&emsp;这个事情是由编译器来实现的，现在的做法是这样的，编译器在编译Java代码时，会复制finally代码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中。

## jvm反射实现
&emsp;&emsp;在默认情况下，方法的反射调用为委派实现，委派给本地实现来进行方法调用。在调用超过 15 次之后，委派实现便会将委派对象切换至动态实现。这个动态实现的字节码是自动生成的，它将直接使用 invoke 指令来调用目标方法。方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。


## jvm如何实现invokeddynamic
&emsp;&emsp;方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。方法句柄的调用和反射调用一样，都是间接调用，同样会面临无法内联的问题。
&emsp;&emsp;invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。

## jvm对象的内存分布
&emsp;&emsp;常见的 new 语句会被编译为 new 指令，以及对构造器的调用。每个类的构造器皆会直接或者间接调用父类的构造器，并且在同一个实例中初始化相应的字段。Java 虚拟机引入了压缩指针的概念，将原本的 64 位指针压缩成 32 位。压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数。Java 虚拟机还会对每个类的字段进行重排列，使得字段也能够内存对齐。
- 对象头
&emsp;&emsp;每个对象都有一个对象头，对象头包括两部分，标记信息和类型指针。
&emsp;&emsp;标记信息包括哈希值，锁信息，GC信息。类型指针指向这个对象的class。
&emsp;&emsp;两个信息分别占用8个字节，所以每个对象的额外内存为16个字节。很消耗内存。
- 压缩指针
为了减少类型指针的内存占用，将64位指针压缩至32位，进而节约内存。之前64位寻址，寻的是字节。现在32位寻址，寻的是变量。再加上内存对齐(补齐为8的倍数)，可以每次寻变量都以一定的规则寻找，并且一定可以找得到。
- 内存对齐
&emsp;&emsp;内存对齐的另一个好处是，使得CPU缓存行可以更好的实施。保证每个变量都只出现在一条缓存行中，不会出现跨行缓存。提高程序的执行效率。
- 字段重排序
&emsp;&emsp;其实就是更好的执行内存对齐标准，会调整字段在内存中的分布，达到方便寻址和节省空间的目的。
- 虚共享
&emsp;&emsp;当两个线程分别访问一个对象中的不同volatile字段，理论上是不涉及变量共享和同步要求的。但是如果两个volatile字段处于同一个CPU缓存行中，对其中一个volatile字段的写操作，会导致整个缓存行的写回和读取操作，进而影响到了另一个volatile变量，也就是实际上的共享问题。
- @Contented注解
&emsp;&emsp;该注解就是用来解决虚共享问题的，被该注解标识的变量，会独占一个CPU缓存行。但也因此浪费了大量的内存空间。
## 垃圾回收
&emsp;&emsp;Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。它从一系列 GC Roots 出发，边标记边探索所有被引用的对象。为了防止在标记过程中堆栈的状态发生改变，Java 虚拟机采取安全点机制来实现 Stop-the-world 操作，暂停其他非垃圾回收线程。回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。
- 垃圾回收-核心工作就是回收垃圾，哪关键点回来了。什么是垃圾？这个垃圾需要分类嘛？怎么定位垃圾？怎么回收垃圾？回收垃圾的方法都有哪些？他们都有什么优缺点？另外，就是我们为什么要学习垃圾回收？
- 站在JVM的视角来看
	- 垃圾-就是无用对象所占用的堆内存空间
	- 垃圾分类-貌似不需要垃圾分类，识别垃圾并回收就行
	- 定位垃圾-是垃圾回收的关键点，无用的对象占用的堆空间即是垃圾，那就需要先定位无用的对象，这里的无用是不再使用的意思，咋判断呢？文中介绍了两种方法，计数法和标记法（祥看原文）核心在于能定位出无用的对象，后出现的方法往往比早出现的更好一点，这里也一样，标记法能解决计数法，解决不了的循环引用不能回收的问题，但是也存在其他的问题，误报和漏报的问题，误报浪费点垃圾回收的机会浪费点空间，漏报在多线程并发工作时可能会死JVM的，所以，比较严重，所以，JVM采用了简单粗暴的stop-the-world的方式来对待，所以，老年代的回收有卡顿的现象
	- 怎么回收垃圾-定位出垃圾，回收就是一个简单的事情了，当然也非常关键，把要回收的堆内存空间标记为可继续使用就行，下次有新对象能在此空间创建就行

&emsp;&emsp;J回收垃圾的方法-文中介绍了三种，清除、压缩、复制
- 清除法-简单，但易产生碎片，可能总空间够但分配不了的问题
- 压缩法-能解决清除法的问题，但是复杂且耗性能
- 复制法-折衷一些，但是空间利用率低，总之，各有千秋

&emsp;&emsp;Java 虚拟机将堆分为新生代和老年代，并且对不同代采用不同的垃圾回收算法。其中，新生代分为 Eden 区和两个大小一致的 Survivor 区，并且其中一个 Survivor 区是空的。
&emsp;&emsp;在只针对新生代的 Minor GC 中，Eden 区和非空 Survivor 区的存活对象会被复制到空的 Survivor 区中，当 Survivor 区中的存活对象复制次数超过一定数值时，它将被晋升至老年代。因为 Minor GC 只针对新生代进行垃圾回收，所以在枚举 GC Roots 的时候，它需要考虑从老年代到新生代的引用。为了避免扫描整个老年代，Java 虚拟机引入了名为卡表的技术，大致地标出可能存在老年代到新生代引用的内存区域。

- 二八法则-适用于许多的领域，对象在JVM对内存空间的生命周期也同样符合

- 为了更好的JVM性能以及充分利用对象生命周期的二八法则，JVM的作者将JVM的对内存空间进行了分代的处理

- 堆内存空间=年轻代+老年代
	- 年轻代=Eden+from+to
	- 年轻代用于分配新生的对象
	- Eden-通常用于存储新创建的对象，对内存空间是共享的，所以，直接在这里面划分空间需要进行同步
	- from-当Eden区的空间耗尽时，JVM便会出发一次Minor GC 来收集新生代的垃圾，会把存活下来的对象放入Survivor区，也就是from区，注意，from和to是变动的
		- to-指向的Survivor区是空的，用于当发生Minor GC 时，存储Eden和from区中的存活对象，然后再交换from和to指针，以保证下一次Minor GC 时to指向的Survivor区还是空的。
		- 老年代-用于存储存活时间更久的对象，比如：15次Minor GC 还存活的对象就放入老年代中
- 堆内存分代后，会根据他们的不同特点来区别对待，进行垃圾回收的时候会使用不同的垃圾回收方式，针对新生代的垃圾回收器有如下三个：Serial、Parallel Scavenge、Parallel New，他们采用的都是标记-复制的垃圾回收算法。
&emsp;&emsp;针对老年代的垃圾回收器有如下三个：Serial Old 、Parallel Old 、CMS，他们使用的都是标记-压缩的垃圾回收算法。
- TLAB（Thread Local Allocation Buffer）-这个技术是用于解决多线程竞争堆内存分配问题的，核心原理是对分配一些连续的内存空间
- 卡表-这个技术是用于解决减少老年代的全堆空间扫描

## java内存模型
&emsp;&emsp;Java 内存模型通过定义了一系列的 happens-before 操作，让应用程序开发者能够轻易地表达不同线程的操作之间的内存可见性。在遵守 Java 内存模型的前提下，即时编译器以及底层体系架构能够调整内存访问操作，以达到性能优化的效果。如果开发者没有正确地利用 happens-before 规则，那么将可能导致数据竞争。Java 内存模型是通过内存屏障来禁止重排序的。对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。
&emsp;&emsp;Java 虚拟机中 synchronized 关键字的实现，按照代价由高至低可分为重量级锁、轻量级锁和偏向锁三种。重量级锁会阻塞、唤醒请求加锁的线程。它针对的是多个线程同时竞争同一把锁的情况。Java 虚拟机采取了自适应自旋，来避免线程在面对非常小的 synchronized 代码块时，仍会被阻塞、唤醒的情况。轻量级锁采用 CAS 操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。它针对的是多个线程在不同时间段申请同一把锁的情况。偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。它针对的是锁仅会被同一线程持有的情况。

## JVM参数

### 参数类型

- 标准参数 -version -help等命令
- X参数 
  -Xint   解释执行
  -Xcomp 第一次使用就编译本地代码
  -Xmined 混合模式
- 重点：XX参数 
  - Boolean类型
    - -XX:+或者-某个属性值 +标识开启，-标识关闭
    - case：如何查看一个正在运行中的jvm的参数 jinfo -flag 参数 进程号;或者使用jinfo -flags 进程号 查看所有的参数
  - kv键值对
  - jinfo类型，如何查看当前运行程序的配置
    两个经典参数：-Xms等价于-XX:InitialHeapSize; -Xmx等价于-XX:MaxHeapSize

### 查看初始参数

- 查看JVM初始值：** java -XX:+PrintFlagsInitial**，安装后默认的值
- 查看修改后的参数值：** java -XX:+PrintFlagsFinal** 人为改过的值会显示 := 没改过的显示=

### 常用的JVM基本配置参数

- Xms： 初始内存大小，默认物理内存1/64，等价于-XX:InitialHeapSize
- Xmx： 最大分配内存，默认物理内存1/4，等价于-XX:MaxHeapSize
- Xss： 设置单个线程栈的大小，一般默认在512k~1024K，等价于-XX:ThreadStackSize，如果jinfo查询结果是0，表示使用默认值，没有设置过
- Xmn： 设置年轻代大小
- -XX:MetaspaceSize： 设置元空间大小，元空间本质和永久代类似，都是对JVM规范中方法区的实现，默认大概21M；元空间与永久代之间的最大的区别在于：
  - 元空间并不在虚拟机中，而是在本地内存中。因此默认情况下，元空间大小仅受到本地内存限制
- 典型设置案例： -Xms 128m -Xmx 4096m -Xss1024k -XX:MetaspaceSiza=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetials -XX:+UseSerialGC
- -XX:+PrintGCDetails GC引擎设置
- -XX:SurvivorRatio： 设置Eden区比例大小（占用新生代的比例），默认是8，即8:1:1，设置为4，即4:1:1
- -XX:NewRatio： 配置年轻代和老年代在堆结构的占比，设置值为2 ，新生代占1，老年代占2；设置值为4，新生代占1，老年代占4
- -XX:MaxTenuringThreshold： 设置对象的年龄最大值，默认15；在jdk8中，设置值最高是15，不同的版本可以设置的最大值不同，值越大，老年代对象越少，full GC发生可能性越小

## 强、软、弱、虚四种引用

### 强引用

最常见的引用，把一个对象赋予给引用变量，这个变量就是强引用，对于强引用，就算是OOM也不会对该对象进行回收

### 软引用

SoftReference引用，当内存满的时候，会对其进行垃圾回收；内存足够的时候，不会进行回收
通常用在内存敏感的程序中，比如高速缓存

### 弱引用

### 一个图片缓存

加入一个应用需要读取大量的本地图片，每次都从硬盘读取严重影响性能，如果一次性加载到内存又可能导致内存溢出，，使用一个HashMap来构建  图片路径：图片对象软引用的映射来作为缓存使用，内存不足时，会自动回收这个空间

```
Map<Srting, SoftReference<BitMmap>> imgCache = new HashMap<>();
```

### WeakHashMap


### 虚引用 PhantomReference

任何时候都可能被垃圾回收，不能单独使用，也不能通过它访问对象，虚引用必须和引用队列联合使用（ReferenceQueue）
虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅提供了一种确保对象被finalize以后，做某些事的机制

### 引用队列 ReferenceQueue


## OOM

java.lang.StackoverFlowError 栈溢出，例如栈中加入过多的方法，比如递归
java.lang.OutOfMemoryError: java heap space 对内存溢出 
java.lang.OutOfMemoryError: GC overhead limit exceeded GC回收时间过长，过长是指98%时间回收了不到2%的内存，连续多次GC都会了不到2%的情况下抛出；
java.lang.OutOfMemoryError: Direct buffer memory 使用NIO时可能会出现
java.lang.OutOfMemoryError: unable to create new native thread 高并发服务经常出现，准确说这个异常（native thread异常）和对应的平台有关
java.lang.OutOfMemoryError: Metaspace 元空间溢出，例如加载过多的动态代理类


## GC算法

GC算法是内存回收的方法论，垃圾回收器是算法的实现
（引用计数、复制、标记清除、标记整理）

主要的垃圾回收器：

- serial 串行垃圾回收器，为单线程环境设计，使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器环境；串行收集器是最古老的最稳定以及效率高的收集器，只是用一个线程进行回收，在回收的过程中需要暂停其他所有的工作线程（STW），但是它简单有效，对于单核CPU来说是效率最高的收集器，新词是client模式下默认的新生代收集器

- Parallel 并行垃圾回收器，多个垃圾线程并行工作，此时用户线程是暂停的
- CMS 并发垃圾回收器(ConcMarkSweep)，用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程
- G1 java8之后使用；将内存分割成不同的区域，然后并发进行垃圾回收
- ZGC java11、12 以后

```
查看默认的垃圾回收器：>java -XX:+PrintCommandLineFlags -version 8使用的是
-XX:+UseParallelGC
```

#### STW（Stop-the-World）

## 垃圾收集器

新声代：

- serial Copying 串行垃圾回收器的实现
- Parallel Scavenge 并行垃圾回收器的实现，俗称吞吐量优先收集器
- ParNew 并行垃圾回收器的一种实现，其实就是Serial收集器的多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余行为和Serial收集器相同，Parallel New垃圾回收器在回收过程中同样也要暂停其他工作线程，它是很多java虚拟机运行在server模式下的新生代的默认垃圾回收器


老年代：

- Serial MSC （Serial Old） 老年代的串行垃圾回收器实现，已经不推荐使用，jdk5之前与新生代的Parallel Scavenge搭配使用；8以后作为CMS的备用使用
- Parallel Compacting （Parallel Old） 老年代并行垃圾回收器的实现
- CMS 并发标记清除，是一种以获取最短回收时间为目标的收集器，是G1出现之前大型应用的首选

G1 两个区域公用，整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片

### 部分参数说明

- DefNew：Default  New Generation
- Tenured：Old
- ParNew：Parallel New Generation 新生代使用并行回收器
- PSYoungGen：Parallel Scavenge
- ParOldGen：Parallel Old Generation

### JDK模式

server模式 client模式

## 垃圾回收器使用参数

- **-XX:+UseSerialGC**；开启后会使用Serial（Young区）+ Serial Old（Old区）的收集器组合；新生代、老年代都使用串行回收器，新生代使用复制算法，老年代使用标记-整理算法
- **-XX:+UseParNewGC **启动ParNew收集器，只影响新生代的手机，不影响老年代，开启上述参数后，会使用ParNew（Young区）+ Serial Old的收集器组合，新生代使用赋值算法，老年代采用标记-整理算法；java8之后不再推荐该组合；可以调整并发的线程数，默认等于CPU核数，可以通过**```-XX:ParallelGCThreads```**调整线程数
- **-XX:+UseParallelGC或者-XX:UseParallelOldGC**（可以互相激活）；意思是，在新生代使用Parallel Scavenge，自动激活老年代使用Parallel Old** jdk6以前是Parallel Scavenge + Serial Old组合，因为Parallel Old在6之后才开始提供**；在老年代使用Parallel Old，自动激活新生代使用Parallel Scavenge；
  开启该参数后，新生代使用赋值算法，老年代使用标记-整理算法
  可以通过```-XX:ParallelGCThreads=N，表示启动多少个GC线程```调整线程数
  cpu > 8 N=5/8
  cpu < 8 N=实际个数
- **-XX:+UseConcMarkSweepGC** 开启后改参数会自动将```-XX:+UseParNewGC```打开；开启后使用ParNew（Young区）+ CMS（Old区）+ Serial Old的收集器组合，Serial作为CMS出错后的备用收集器；
  四个步骤：
  - 初始标记（CMS initial mark）会stop the world
  - 并发标记（CMS concurrent mark）和用户线程一起，进行GC Roots跟踪的过程，不需要暂停工作线程，主要是标记过程
  - 重新标记（CMS remark），也叫CMS final Remark；会stop the world ；修正因用户程序继续运行而导致标记变动的那一部分对象的标记记录；会暂停所有工作线程
  - 并发清除（CMS concurrent sweep）和用户线程一起，清除GC Roots不可达对象；
    优缺点：
    优点：并发执行，停顿低
    缺点：
  - 并发执行，CPU占用率高；**由于并发执行，CMS在手机与应用线程同时工作，会增加对堆内存的占用，所以，CMS必须要在老年代堆内存用尽之前使用，否则会回收失败，这时候会触发担保机制，使用Serial Old以STW的方式进行一次GC，造成比较大的停顿时间**
  - 使用标记清除，产生大量碎片

- ** -XX:+UseG1GC**


## 垃圾回收器的选择

- 单CPU或者小内存，单机程序 -XX:+UseSerialGC
- 多CPU，需要大吞吐量，如后台计算型应用 
  - -XX:+useParallelGC
  - -XX:+UseParallelOldGC
- 多CPU，追求低停顿时间，需要快速响应如互联网应用
  - -XX:+UseConcMarkSweepGC
  - -XX:+ParNewGC

## G1

### 简要说明

jdk7首次出现，jdk9开始作为默认收集器使用

- 为了取代CMS设计的收集器，能充分利用CPU、多核硬件环境的优势，尽量缩短STW
- 整体上采用标记-整理算法；
- 局部通过复制算法，不会产生很多内存碎片；
- 宏观上不再区分年轻代和老年代
- 小范围内依然要进行年轻代和老年代的区分，保留了新生代和老年代，但不再是物理隔离的，而是一部分Region的集合并且不需要Region是连续的，就是说依然会用不同的GC方式处理不同区域
- G1虽然也是分带收集器，但是整个内存不存在物理上的老年代和年轻代的区别，也不需要完全独立的survivor堆做赋值准备，G1只有逻辑上的分带概念，或者说每个分区都可能随G1的运行在不同代之间前后切换
- G1的STW更加可控，G1在停顿时间上添加了预测机制，用户可以指定期望大的停顿时间
  **主要改变是Eden、survivor和Tenured等区域不再是连续的了，而是变成了一个个大小一样大的region，每个region从1M到32M不等，一个region可能属于Eden、survivor或Tenured**

### 区域（region）的说明

可以通过参数-XX:G1HeapRegionSize=n设置区域的大小（1M~32M，必须是2的幂），默认将整个堆划分为2048个分区，最多能设置2048个区域，即：最大支持内存为```2048*32M = 64G```

区域分为四种：

- Eden：
- Survivor
- Old
- Humongous [hjuːˈmʌŋɡəs]：大对象区，如果一个对象占用的空间超过了分区容量的50%，认为这是一个大对象（这些对象默认分配在老年代，但是如果这个对象是短期存在，就会对垃圾回收器造成负面影响），为解决这个问题，G1使用Humongous区来存放大对象；如果一个H区装不下一个大对象，G1会寻找连续的H区来存储；为了找到连续的H区，有时候不得不启动FullGC
- 空白区

### 回收过程

G1的Young GC
针对Eden区进行收集，Eden耗尽的时候触发，主要是小区域收集+形成连续的内存块，避免内存碎片
逻辑过程

- 1.Eden区的数据移动到Survivor区，加入Survivor区空间不够，Eden区数据就会晋升到Old区
- 2.Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区
- 3.最后Eden区收拾干净了，GC结束，用户应用程序继续进行

过程类似于CMS

- 1.初始标记 只标记GC Roots能直接关联到的对象 会STW
- 2.并发标记 进行GC Roots Tracing的过程 与用户线程一起执行
- 3.最终标记 修正并发标记期间，因程序需运行导致的标记变化的对象 会STW
- 4.筛选回收 根据时间来进行价值最大化的回收 会STW

### G1常用参数

- -XX:+UseG1GC
- -XX:G1HeapRegionSize=n 设置G1区域大小，值是2的幂，范围1~32M，目标是根据最小的java堆大小划分出约2048个区域
- -XX:MaxGCPAuseMillis=n 最大GC停留时间，这个事软目标，JVM尽可能停顿小于这个时间，但不保证
- -XX:InitiatingHeapOccupancyPerent=n 堆占用了多少的时候触发GC，默认45
- -XX:ConcGCThreads=n 并发GC的线程数
- -XX:G1ReservePercent=n 设置作为空闲空间预留的内存百分比，以降低目标空间溢出的风险，默认值是10%

### 与CMS对比相比的优势

- G1没有内存碎片
- 可以控制停顿，通过参数MaxGCPAuseMillis控制，每次根据允许停顿时间手机垃圾最多的区域

## 生产环境服务器变慢，如何诊断和调优

使用```java -server jvm的各种参数设置 -jar 文件路径```命令设置参数并启动服务

linuxX:ConcGCThreads=n 并发GC的线程数

- -XX:G1ReservePercent=n 设置作为空闲空间预留的内存百分比，以降低目标空间溢出的风险，默认值是10%

### 与CMS对比相比的优势

- G1没有内存碎片
- 可以控制停顿，通过参数MaxGCPAuseMillis控制，每次根据允许停顿时间手机垃圾最多的区域

## 生产环境服务器变慢，如何诊断和调优

使用```java -server jvm的各种参数设置 -jar 文件路径```命令设置参数并启动服务

linux命令 :

- 整机状态查看
  ps -ef|gerp java查看所有java进程
  - top或者uptime查看系统负载情况；右上角load average后的三个数是1分钟，五分钟，十五分钟的负载情况，1.0代表完全负载，2.0代表两倍负载
- CPU
  - vmstat -n 2 3 两个参数，一个是采样间隔，单位是秒；第二个是采样次数
    -procs
    	- r：运行和等待CPU时间片的进程数，原则上1核CPU的运行队列不要超过2，整个系统运行队列不能超过总核数的2倍，否则代表系统压力过大
    	- b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等
    - CPU
      - us：用户进程消耗CPU时间的百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，可能需要优化程序
      - sy：内核进程消耗的CPU时间百分比
      - us+sy参考值为80%，如果大于这个值，说明可能存在CPU不足
      - id idle处于空闲的CPU百分比
      - wa：系统等待IO的CPU时间百分比
      - st：来自于一个虚拟机偷取的CPU时间百分比
  - 查看所有CPU核的信息 mpstat -P ALL 2 表示2秒打印一次。打印所有CPU的信息
  - 每个进程使用cpu用量分解信息 pidstat -u 1 -p 进程编号，
- 内存 
  - free 查看内存使用状况
  - free -g 以G为单位显示结果
  - free -m 以M为单位显示结果
  - pidstat -p 进程数 -r 采样间隔秒数
- 硬盘
  - df 查看磁盘剩余空间数 df -h
- 磁盘I/O
  - iostat：磁盘I/O性能评估 iostat -xdk 2 3 标识采样间隔2秒，采样3次
  - pidstat -d 采样间隔秒数 -p 进程号
- 网络I/O
  - ifstat默认本地没有，需要下载一个 ifstat 1 1是采样间隔
    - wget http://gael.roualland.freefr/ifstat-1.1.tar.gz
    - tar xzvf ifstat-1.1.tar.gz
    - cd ifstat-1.1
    - ./configure
    - make
    - make install

## CPU占用过高，如何分析思路和定位

- 使用top查看CPU查看最高的进程
- ps -ef或者jps进一步定位，得知进程信息
- 定位具体线程或者代码
  - ps -mp 进程 -o THREAD,tid,time 其中tid是线程id
    - -m显示所有的线程
    - -p pid进程使用cpu的时间
    - -o 该参数后是用户自定义格式
- 将需要的线程ID转换为16进制格式（英文小写格式）
  - printf "%x\n" 线程号
- jstatck 进程号 | grep 线程号（16进制，英文小写） -A60   -A60表示打印前60行
  直接定位到问题代码





## 垃圾回收
### 如何确定垃圾
不再被使用的对象被称为垃圾
#### 引用计数法：
对象每被引用一次，就加1，减少一个就减1，不能解决循环引用的问题
#### 可达性分析 根搜索路径
GC Roots ；基本思路就是通过一系列名为“GC Roots”的对象作为起点，从这些对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用；标记可达对象；
** GC Roots是一组必须活跃的引用** ----- GC Roots Set
##### 哪些对象可以作为GC Roots？
- 虚拟机栈（栈帧中的局部变量，也叫局部变量表）中引用的对象
- 方法去中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象

##  逃逸分析、栈上分配、标量替换、同步消除

1、先来个开胃菜（灵魂拷问）：
下面这两份代码哪个好，（从jvm层面考虑的话）好在哪？

public StringBuffer createString1(String ... values){
    StringBuffer stringBuffer = new StringBuffer();
    for (String string : values) {
        stringBuffer.append(string+" ");
    }
    return stringBuffer;
}
public String createString2(String ... values){
    StringBuffer stringBuffer = new StringBuffer();
    for (String string : values) {
        stringBuffer.append(string+" ");
    }
    return stringBuffer.toString();
}
看完我下面的文章之后就知道了。

2、逃逸分析
逃逸分析是编译语言中的一种优化分析，而不是一种优化的手段。通过对象的作用范围的分析，为其他优化手段提供分析数据从而进行优化。

是不是听得有点懵？用“土鳖”一点的大白话来说就是，在方法内你new出来的对象只能在方法内随便折腾（业务逻辑处理），但是你不能逃逸出方法的这个一亩三分地而为外部方法所利用。再精简一点可以理解成：对象在我方法内活着，出方法则消亡。

逃逸分析的场景包括：
全局变量赋值逃逸
方法返回值逃逸
实例引用发生逃逸
线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量
```
public class EscapeAnalysis {

     public static Object object;
     
     //全局变量赋值逃逸
     public void globalVariableEscape(){
         object =new Object();  
      }
      
     //方法返回值逃逸：方法内new出来的对象逃离案发现场（即方法范围）而有机会被其他方法获取该对象
     public Object methodEscape(){  
         return new Object();
     }
     
     //实例引用发生逃逸
     public void instancePassEscape(){ 
        this.speak(this);
     }
     
     public void speak(EscapeAnalysis escapeAnalysis){
         System.out.println("Escape Hello");
     }
}
```
```
-XX:+DoEscapeAnalysis  开启逃逸分析
-XX:-DoEscapeAnalysis  关闭逃逸分析
通过jmap -histo [pid]查看java堆上的对象分布情况:
```
2、标量替换
2.1、标量和聚合量
标量（scalar replacement）：就是不能再被分解的量。（例如八大基本类型 byte , short , int ,long ,char , float ,double , boolean）另外指向对象的引用也是标量。
聚合量（aggregate）就是还能继续被分解的量，例如对象能被分解成多个标量。

如果把一个Java对象拆散，将其成员变量恢复为分散的变量，这就叫做标量替换。拆散后的变量便可以被单独分析与优化，可以各自分别在活动记录（栈帧或寄存器）上分配空间；原本的对象就无需整体分配空间了。

2.2、替换过程
通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间。
```
-XX:+EliminateAllocations  可以开启标量替换
-XX:+PrintEliminateAllocations  查看标量替换情况（Server VM 非Product版本支持）
```
**开启逃逸分析和标量替换可以实现栈上分配，减轻GC压力；但是jvm需要在server模式下运行**

3、栈上分配
震惊？！不是所有的对象都在堆上分配内存空间！

只有发生了逃逸的对象，才会在堆上分配内存，JIT即使编译技术优化中加入了逃逸分析，就是专门分析对象是否发生逃逸的，如果发现对象的作用域仅限于本方法内，也就是外部没有任何引用，那么就让对象在栈帧执行到该方法时在栈上分配内存。随着方法执行完毕，返回一个标量基本数据类型后，栈帧弹出栈，所有分配的内存回收，当然也包括那个对象的内存，所以这效率肯定比GC不知道啥时候才来打扫卫生要高得多。

4、同步消除（又称为锁消除）

通过-XX:+EliminateLocks可以开启同步消除,进行测试执行的效率
同步消除是java虚拟机提供的一种优化技术。这里消除的其实是对象的同步锁，堆被线程共享，那么堆上面的对象也会被线程共享，大家一起读写，会出现同步的并发问题，所以对象也加了synchronized同步锁。但是栈是线程独享的，如果进行栈上分配，那么就根本不需要同步锁，提高了执行效率。这就是同步消除。

5、做逃逸分析有什么好处
经过上面的总结可以发现：
（1）消除了同步锁，提高了运行速度。
（2）减轻了垃圾收集子系统GC的负担，标量替换使得减少了对象回收的一串漫长流程。
（3）提高了内存利用率，栈上分配可以更好管理内存使用和回收。

震惊？！这么多好处！JDK中逃逸分析居然还不成熟？！

这个概念书上说1999年就提出来了，是非常好的一个想法，但是直到现在也还不成熟，因为代码编写的原因，没有严格限制返回类型，图方便我也会整个对象返回。又因为整个逃逸分析流程较长（整套逃逸分析，标量替换，栈上分配，同步消除，整套大宝剑做下来也很耗费性能资源）。结果就造成整套分析下来全部对象还要乖乖在堆上分配内存。速度更慢了。
但是这是即时编译技术JIT的非常好的一个模式，相信将来会有更大的发展空间。

最后良心赠送一张JVM底层对对象的处理流程图，大家自己去理解吧，本文就不再展开了讲解了。

本文最后给大家一点个人的小建议，其实所有的知识都是串联的。希望大家通过本文能够将JVM逃逸分析，synchronized锁的底层实现，JVM垃圾回收等知识融会贯通形成自己的知识体系，同时反思自己平常写的代码中是否有注意到进行标量替换来提升代码执行效率。

